# -*- coding: utf-8 -*-
"""Recommendations based on the userâ€™s recent browsing or purchase history using collaborative.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14RlAVjAipKZoFfmKEvzmn4b11HwE6lhL
"""

!pip install redis pandas scikit-learn numpy
!apt-get install redis-server
!redis-server --daemonize yes

import numpy as np
import pandas as pd
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.feature_extraction.text import TfidfVectorizer
from collections import defaultdict
import datetime
import redis
import json

class RecommendationSystem:
    def __init__(self, redis_host='localhost', redis_port=6379):
        self.redis_client = redis.Redis(host=redis_host, port=redis_port, decode_responses=True)
        self.cache_ttl = 3600  # Cache TTL in seconds (1 hour)

        # Storage for user and product data
        self.user_product_matrix = defaultdict(lambda: defaultdict(float))
        self.product_features = {}
        self.user_history = defaultdict(list)

    def add_product(self, product_id, features):
        """Add or update product features"""
        self.product_features[product_id] = features

    def record_user_interaction(self, user_id, product_id, interaction_type, timestamp=None):
        """Record user interaction with a product"""
        if timestamp is None:
            timestamp = datetime.datetime.now()
        weights = {
            'view': 1.0,
            'add_to_cart': 2.0,
            'purchase': 3.0
        }

        weight = weights.get(interaction_type, 1.0)
        self.user_product_matrix[user_id][product_id] += weight

        # Update user history with times
        self.user_history[user_id].append({
            'product_id': product_id,
            'timestamp': timestamp,
            'interaction_type': interaction_type
        })
        self.redis_client.delete(f"recommendations:{user_id}")

    def _calculate_content_based_recommendations(self, user_id, n=5):
        """Calculate content-based recommendations based on user's interaction history"""
        if not self.user_history[user_id]:
            return []

        # Create vectors for product
        tfidf = TfidfVectorizer()
        product_features_text = [
            ' '.join(str(v) for v in self.product_features[p['product_id']].values())
            for p in self.user_history[user_id]
        ]

        # Similarity between products
        product_vectors = tfidf.fit_transform(product_features_text)
        similarity_matrix = cosine_similarity(product_vectors)

        # Get recently  products
        recent_products = [p['product_id'] for p in sorted(
            self.user_history[user_id],
            key=lambda x: x['timestamp'],
            reverse=True
        )[:5]]

        #  Recommendations based on similar products
        recommendations = defaultdict(float)
        for idx, product_id in enumerate(recent_products):
            similar_products = similarity_matrix[idx]
            for sim_idx, similarity in enumerate(similar_products):
                sim_product_id = self.user_history[user_id][sim_idx]['product_id']
                if sim_product_id not in recent_products:
                    recommendations[sim_product_id] += similarity

        return sorted(recommendations.items(), key=lambda x: x[1], reverse=True)[:n]

    def _calculate_collaborative_recommendations(self, user_id, n=5):
        """Calculate collaborative filtering recommendations"""
        if not self.user_product_matrix[user_id]:
            return []

        # Create User similarity matrix
        user_vectors = pd.DataFrame.from_dict(self.user_product_matrix, orient='index')
        user_vectors = user_vectors.fillna(0)

        # User similarity
        user_similarity = cosine_similarity(user_vectors)
        user_similarity_df = pd.DataFrame(
            user_similarity,
            index=user_vectors.index,
            columns=user_vectors.index
        )


        similar_users = user_similarity_df[user_id].sort_values(ascending=False)[1:6]

        # Calculate recommendations based on similar users' interactions
        recommendations = defaultdict(float)
        for sim_user, similarity in similar_users.items():
            for product_id, rating in self.user_product_matrix[sim_user].items():
                if product_id not in self.user_product_matrix[user_id]:
                    recommendations[product_id] += similarity * rating

        return sorted(recommendations.items(), key=lambda x: x[1], reverse=True)[:n]

    def get_recommendations(self, user_id, n=5):
        """Get hybrid recommendations combining both approaches"""
        # Check cache first
        cached_recommendations = self.redis_client.get(f"recommendations:{user_id}")
        if cached_recommendations:
            return json.loads(cached_recommendations)
        content_based = self._calculate_content_based_recommendations(user_id, n)
        collaborative = self._calculate_collaborative_recommendations(user_id, n)

        # Combine and weight
        final_recommendations = defaultdict(float)
        for product_id, score in content_based:
            final_recommendations[product_id] += score * 0.6  # 60% weight

        for product_id, score in collaborative:
            final_recommendations[product_id] += score * 0.4  # 40% weight

        # Sort Top N recommendations
        recommendations = sorted(
            final_recommendations.items(),
            key=lambda x: x[1],
            reverse=True
        )[:n]

        # Results
        self.redis_client.setex(
            f"recommendations:{user_id}",
            self.cache_ttl,
            json.dumps(recommendations)
        )

        return recommendations

    def update_product_features(self, product_id, features):
        """Update product features and clear affected caches"""
        self.product_features[product_id] = features

        # Clear cached recommendations for users who interacted with this product
        for user_id, history in self.user_history.items():
            if any(p['product_id'] == product_id for p in history):
                self.redis_client.delete(f"recommendations:{user_id}")

# Usage
if __name__ == "__main__":
    # Recommendation system
    recommender = RecommendationSystem()

    # Sample products
    sample_products = {
        'P1': {'category': 'electronics', 'brand': 'Apple', 'price_range': 'high'},
        'P2': {'category': 'electronics', 'brand': 'Samsung', 'price_range': 'high'},
        'P3': {'category': 'electronics', 'brand': 'Xiaomi', 'price_range': 'medium'},
    }

    for product_id, features in sample_products.items():
        recommender.add_product(product_id, features)

    # User interactions
    recommender.record_user_interaction('user1', 'P1', 'purchase')
    recommender.record_user_interaction('user1', 'P2', 'view')
    recommender.record_user_interaction('user2', 'P2', 'purchase')
    recommender.record_user_interaction('user2', 'P3', 'add_to_cart')

    # Get Recommendations
    recommendations = recommender.get_recommendations('user1', n=2)
    print(f"Recommendations for user1: {recommendations}")